#!/usr/bin/env python3
"""
Robust AutoPoster API Server for M1A Integration
This is a more reliable FastAPI-based server
"""

import uvicorn
from fastapi import FastAPI, HTTPException, UploadFile, File, Form
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import json
import os
from datetime import datetime, timedelta
import uuid
import asyncio
import base64

# Initialize FastAPI app
app = FastAPI(
    title="M1A AutoPoster API",
    description="Robust API for M1A AutoPoster integration",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Data models
class ContentGenerationRequest(BaseModel):
    prompt: str
    content_type: str
    platform: str
    brand_voice: str
    target_audience: str

class ContentGenerationResponse(BaseModel):
    success: bool
    content: Optional[str] = None
    message: Optional[str] = None

class PostData(BaseModel):
    uid: str
    content: str
    imageUrl: Optional[str] = None
    platforms: Dict[str, bool]
    scheduledTime: str
    status: str
    autoGenerated: bool
    createdAt: str

class ServiceBookingRequest(BaseModel):
    userId: str
    serviceId: str
    serviceName: str
    serviceDate: str
    serviceTime: str
    quantity: int = 1
    contactName: str
    contactEmail: str
    contactPhone: Optional[str] = None
    specialRequests: Optional[str] = None
    totalCost: float
    subtotal: float
    tax: float
    serviceFee: float

class ServiceBookingResponse(BaseModel):
    success: bool
    bookingId: Optional[str] = None
    error: Optional[str] = None
    message: Optional[str] = None

class BarOrderItem(BaseModel):
    id: str
    name: str
    price: float
    quantity: int

class BarOrderRequest(BaseModel):
    userId: str
    items: List[BarOrderItem]
    subtotal: float
    tax: float
    serviceFee: float
    total: float
    category: str
    specialInstructions: Optional[str] = None

class BarOrderResponse(BaseModel):
    success: bool
    orderId: Optional[str] = None
    error: Optional[str] = None
    message: Optional[str] = None

# In-memory storage
scheduled_posts = []
media_library = []
auto_poster_status = {"enabled": False}
service_bookings = []  # Store service bookings
bar_orders = []  # Store bar orders

# API Endpoints

@app.get("/")
async def root():
    return {"message": "M1A AutoPoster API is running!", "version": "1.0.0", "status": "operational"}

@app.get("/api/health")
async def health_check():
    return {
        "status": "healthy", 
        "timestamp": datetime.now().isoformat(),
        "server": "operational",
        "posts_count": len(scheduled_posts),
        "auto_poster_enabled": auto_poster_status["enabled"]
    }

@app.post("/api/generate-content", response_model=ContentGenerationResponse)
async def generate_content(request: ContentGenerationRequest):
    """Generate content using AI (enhanced version)"""
    try:
        # Enhanced content generation with better formatting
        generated_content = f"""
ðŸŽ¯ **{request.content_type.title()} for {request.platform.title()}**

**Prompt:** {request.prompt}

**Brand Voice:** {request.brand_voice}
**Target Audience:** {request.target_audience}

**Generated Content:**
This is a professionally generated post based on your prompt. The content is optimized for {request.platform} and tailored for your {request.target_audience} audience with a {request.brand_voice} tone.

Key points covered:
â€¢ Engaging hook that captures attention
â€¢ Clear value proposition
â€¢ Call-to-action that drives engagement
â€¢ Relevant hashtags for maximum reach

#content #socialmedia #automation #m1a
        """.strip()
        
        return ContentGenerationResponse(
            success=True,
            content=generated_content,
            message="Content generated successfully"
        )
    except Exception as e:
        return ContentGenerationResponse(
            success=False,
            message=f"Error generating content: {str(e)}"
        )

@app.post("/api/schedule-post")
async def schedule_post(post_data: PostData):
    """Schedule a new post"""
    try:
        post_id = str(uuid.uuid4())
        post = {
            "id": post_id,
            "uid": post_data.uid,
            "content": post_data.content,
            "imageUrl": post_data.imageUrl,
            "platforms": post_data.platforms,
            "scheduledTime": post_data.scheduledTime,
            "status": post_data.status,
            "autoGenerated": post_data.autoGenerated,
            "createdAt": post_data.createdAt
        }
        scheduled_posts.append(post)
        
        return {"success": True, "postId": post_id, "message": "Post scheduled successfully"}
    except Exception as e:
        return {"success": False, "message": f"Error scheduling post: {str(e)}"}

@app.get("/api/scheduled-posts")
async def get_scheduled_posts():
    """Get all scheduled posts"""
    try:
        return {
            "success": True,
            "posts": scheduled_posts,
            "message": "Scheduled posts retrieved successfully"
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Error retrieving scheduled posts: {str(e)}"
        }

@app.get("/api/media-library")
async def get_media_library():
    """Get media library"""
    try:
        return {
            "success": True,
            "media": media_library,
            "message": "Media library retrieved successfully"
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Error retrieving media library: {str(e)}"
        }

@app.post("/api/upload-media")
async def upload_media(
    media: UploadFile = File(...),
    userId: str = Form(...),
    title: str = Form("Untitled Media")
):
    """Upload media to the library"""
    try:
        # Read file content
        contents = await media.read()
        
        # Create media entry
        media_id = str(uuid.uuid4())
        media_entry = {
            "id": media_id,
            "name": title,
            "uri": f"data:{media.content_type};base64,{base64.b64encode(contents).decode()}",
            "type": media.content_type.split('/')[0] if '/' in media.content_type else "image",
            "createdAt": datetime.now().isoformat(),
            "userId": userId
        }
        
        media_library.append(media_entry)
        
        return {
            "success": True,
            "status": "success",
            "media": media_entry,
            "message": "Media uploaded successfully"
        }
    except Exception as e:
        return {
            "success": False,
            "status": "error",
            "message": f"Error uploading media: {str(e)}"
        }

@app.get("/api/auto-poster-status")
async def get_auto_poster_status():
    """Get auto poster status"""
    try:
        return {
            "success": True,
            "enabled": auto_poster_status["enabled"],
            "message": "Auto poster status retrieved successfully"
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Error retrieving auto poster status: {str(e)}"
        }

@app.post("/api/toggle-auto-poster")
async def toggle_auto_poster(request: Dict[str, Any]):
    """Toggle auto poster on/off"""
    try:
        enabled = request.get('enabled', False)
        auto_poster_status["enabled"] = enabled
        return {
            "success": True,
            "enabled": enabled,
            "message": f"Auto poster {'enabled' if enabled else 'disabled'} successfully"
        }
    except Exception as e:
        return {
            "success": False,
            "message": f"Error toggling auto poster: {str(e)}"
        }

@app.get("/api/analytics")
async def get_analytics():
    """Get analytics data"""
    try:
        analytics = {
            "totalPosts": len(scheduled_posts),
            "activePosts": len([p for p in scheduled_posts if p["status"] == "scheduled"]),
            "completedPosts": len([p for p in scheduled_posts if p["status"] == "completed"]),
            "autoPosterEnabled": auto_poster_status["enabled"],
            "mediaCount": len(media_library) if media_library else 3
        }
        return {"success": True, "analytics": analytics}
    except Exception as e:
        return {"success": False, "message": f"Error retrieving analytics: {str(e)}"}

@app.get("/api/platform-settings")
async def get_platform_settings():
    """Get platform settings"""
    try:
        settings = {
            "instagram": {"enabled": True, "connected": False, "name": "Instagram"},
            "facebook": {"enabled": True, "connected": False, "name": "Facebook"},
            "twitter": {"enabled": True, "connected": False, "name": "Twitter"}
        }
        return {"success": True, "settings": settings}
    except Exception as e:
        return {"success": False, "message": f"Error retrieving platform settings: {str(e)}"}

@app.post("/api/test-connection/{platform}")
async def test_platform_connection(platform: str):
    """Test platform connection"""
    try:
        return {
            "success": True,
            "platform": platform,
            "connected": False,
            "message": f"Connection test for {platform} completed (mock response)"
        }
    except Exception as e:
        return {"success": False, "message": f"Error testing connection: {str(e)}"}

# Event Booking Models
class EventBookingRequest(BaseModel):
    userId: str
    eventType: str
    eventDate: str
    eventStartTime: str
    guestCount: int
    duration: int
    firstName: str
    lastName: str
    email: str
    phone: Optional[str] = None
    barPackage: Optional[str] = None
    bundlePackage: Optional[str] = None
    addOnServices: Optional[List[str]] = []
    specialRequirements: Optional[str] = None
    notes: Optional[str] = None
    totalCost: float
    isWeekday: bool = False

class EventBookingResponse(BaseModel):
    success: bool
    bookingId: Optional[str] = None
    message: Optional[str] = None
    error: Optional[str] = None

# In-memory storage for bookings (in production, use database)
event_bookings = []

@app.post("/api/event-booking", response_model=EventBookingResponse)
async def create_event_booking(booking: EventBookingRequest):
    """Create a new event booking"""
    try:
        # Validate required fields
        if not booking.eventType or not booking.eventDate or not booking.eventStartTime:
            return EventBookingResponse(
                success=False,
                error="Missing required fields: eventType, eventDate, eventStartTime"
            )
        
        if not booking.firstName or not booking.lastName or not booking.email:
            return EventBookingResponse(
                success=False,
                error="Missing required contact information"
            )
        
        # Generate booking ID
        booking_id = str(uuid.uuid4())
        
        # Create booking record
        booking_record = {
            "id": booking_id,
            "userId": booking.userId,
            "eventType": booking.eventType,
            "eventDate": booking.eventDate,
            "eventStartTime": booking.eventStartTime,
            "guestCount": booking.guestCount,
            "duration": booking.duration,
            "firstName": booking.firstName,
            "lastName": booking.lastName,
            "email": booking.email,
            "phone": booking.phone,
            "barPackage": booking.barPackage,
            "bundlePackage": booking.bundlePackage,
            "addOnServices": booking.addOnServices or [],
            "specialRequirements": booking.specialRequirements,
            "notes": booking.notes,
            "totalCost": booking.totalCost,
            "isWeekday": booking.isWeekday,
            "status": "pending",
            "createdAt": datetime.now().isoformat(),
            "updatedAt": datetime.now().isoformat()
        }
        
        # Store booking (in production, save to database)
        event_bookings.append(booking_record)
        
        return EventBookingResponse(
            success=True,
            bookingId=booking_id,
            message="Event booking created successfully"
        )
    except Exception as e:
        return EventBookingResponse(
            success=False,
            error=f"Error creating booking: {str(e)}"
        )

@app.get("/api/event-bookings")
async def get_event_bookings(userId: Optional[str] = None):
    """Get event bookings, optionally filtered by userId"""
    try:
        if userId:
            user_bookings = [b for b in event_bookings if b.get("userId") == userId]
            return {
                "success": True,
                "bookings": user_bookings,
                "count": len(user_bookings)
            }
        else:
            return {
                "success": True,
                "bookings": event_bookings,
                "count": len(event_bookings)
            }
    except Exception as e:
        return {
            "success": False,
            "error": f"Error retrieving bookings: {str(e)}"
        }

@app.post("/api/service-booking", response_model=ServiceBookingResponse)
async def create_service_booking(booking: ServiceBookingRequest):
    """Create a service booking"""
    try:
        # Validate required fields
        if not booking.serviceId or not booking.serviceName:
            return ServiceBookingResponse(
                success=False,
                error="Missing required fields: serviceId, serviceName"
            )
        
        if not booking.serviceDate or not booking.serviceTime:
            return ServiceBookingResponse(
                success=False,
                error="Missing required fields: serviceDate, serviceTime"
            )
        
        if not booking.contactName or not booking.contactEmail:
            return ServiceBookingResponse(
                success=False,
                error="Missing required contact information"
            )
        
        # Generate booking ID
        booking_id = str(uuid.uuid4())
        
        # Create booking record
        booking_record = {
            "id": booking_id,
            "userId": booking.userId,
            "serviceId": booking.serviceId,
            "serviceName": booking.serviceName,
            "serviceDate": booking.serviceDate,
            "serviceTime": booking.serviceTime,
            "quantity": booking.quantity,
            "contactName": booking.contactName,
            "contactEmail": booking.contactEmail,
            "contactPhone": booking.contactPhone,
            "specialRequests": booking.specialRequests,
            "subtotal": booking.subtotal,
            "tax": booking.tax,
            "serviceFee": booking.serviceFee,
            "totalCost": booking.totalCost,
            "status": "pending",
            "createdAt": datetime.now().isoformat(),
            "updatedAt": datetime.now().isoformat()
        }
        
        # Store booking (in production, save to database)
        service_bookings.append(booking_record)
        
        return ServiceBookingResponse(
            success=True,
            bookingId=booking_id,
            message="Service booking created successfully"
        )
    except Exception as e:
        return ServiceBookingResponse(
            success=False,
            error=f"Error creating service booking: {str(e)}"
        )

@app.get("/api/service-bookings")
async def get_service_bookings(userId: Optional[str] = None):
    """Get service bookings, optionally filtered by userId"""
    try:
        if userId:
            user_bookings = [b for b in service_bookings if b.get("userId") == userId]
            return {
                "success": True,
                "bookings": user_bookings,
                "count": len(user_bookings)
            }
        else:
            return {
                "success": True,
                "bookings": service_bookings,
                "count": len(service_bookings)
            }
    except Exception as e:
        return {
            "success": False,
            "error": f"Error retrieving service bookings: {str(e)}"
        }

@app.post("/api/bar-order", response_model=BarOrderResponse)
async def create_bar_order(order: BarOrderRequest):
    """Create a bar order"""
    try:
        # Validate required fields
        if not order.items or len(order.items) == 0:
            return BarOrderResponse(
                success=False,
                error="Order must contain at least one item"
            )
        
        if order.total <= 0:
            return BarOrderResponse(
                success=False,
                error="Order total must be greater than 0"
            )
        
        # Generate order ID
        order_id = str(uuid.uuid4())
        
        # Create order record
        order_record = {
            "id": order_id,
            "userId": order.userId,
            "items": [item.dict() for item in order.items],
            "subtotal": order.subtotal,
            "tax": order.tax,
            "serviceFee": order.serviceFee,
            "total": order.total,
            "category": order.category,
            "specialInstructions": order.specialInstructions,
            "status": "pending",
            "createdAt": datetime.now().isoformat(),
            "updatedAt": datetime.now().isoformat()
        }
        
        # Store order (in production, save to database)
        bar_orders.append(order_record)
        
        return BarOrderResponse(
            success=True,
            orderId=order_id,
            message="Bar order created successfully"
        )
    except Exception as e:
        return BarOrderResponse(
            success=False,
            error=f"Error creating bar order: {str(e)}"
        )

@app.get("/api/bar-orders")
async def get_bar_orders(userId: Optional[str] = None):
    """Get bar orders, optionally filtered by userId"""
    try:
        if userId:
            user_orders = [o for o in bar_orders if o.get("userId") == userId]
            return {
                "success": True,
                "orders": user_orders,
                "count": len(user_orders)
            }
        else:
            return {
                "success": True,
                "orders": bar_orders,
                "count": len(bar_orders)
            }
    except Exception as e:
        return {
            "success": False,
            "error": f"Error retrieving bar orders: {str(e)}"
        }

@app.get("/api/dashboard/stats")
async def get_dashboard_stats(userId: Optional[str] = None, persona: Optional[str] = None):
    """Get dashboard stats for a user based on their persona"""
    try:
        if not userId:
            return {
                "success": False,
                "error": "userId is required"
            }
        
        # In production, query from database
        # For now, return zero stats (real data will come from Firestore on frontend)
        stats = {
            "totalEvents": 0,
            "upcomingEvents": 0,
            "completedTasks": 0,
            "revenue": 0,
        }
        
        # TODO: Query real data from database/Firestore
        # - Count event bookings for userId
        # - Count upcoming events (eventDate >= today)
        # - Count completed tasks
        # - Sum revenue from completed bookings
        
        return {
            "success": True,
            "stats": stats,
            "persona": persona or "promoter"
        }
    except Exception as e:
        return {
            "success": False,
            "error": f"Error retrieving dashboard stats: {str(e)}"
        }

# Include payment routes
try:
    from api.payments import router as payments_router
    app.include_router(payments_router)
    print("[OK] Payment routes loaded")
except ImportError as e:
    print(f"[WARN] Payment routes not available: {e}")
    # Payments module not available, skip
    pass

if __name__ == "__main__":
    print("Starting M1A AutoPoster API Server...")
    print("API will be available at: http://localhost:8001")
    print("API Documentation: http://localhost:8001/docs")
    print("Health check: http://localhost:8001/api/health")
    
    # Run the server
    uvicorn.run(
        "robust_api:app",
        host="0.0.0.0",
        port=8001,
        reload=False,
        log_level="info"
    )
